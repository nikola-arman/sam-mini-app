<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>EternalAI Studio</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    :root {
      --bg: var(--tg-theme-bg-color, #1a1a2e);
      --bg2: var(--tg-theme-secondary-bg-color, #16213e);
      --text: var(--tg-theme-text-color, #fff);
      --hint: var(--tg-theme-hint-color, #888);
      --accent: var(--tg-theme-button-color, #7c3aed);
      --accent-text: var(--tg-theme-button-text-color, #fff);
      --link: var(--tg-theme-link-color, #7c3aed);
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 12px;
      transition: background 0.3s, color 0.3s;
    }
    
    .container { max-width: 400px; margin: 0 auto; }
    
    /* Animations */
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    @keyframes shimmer { 0% { background-position: -200% 0; } 100% { background-position: 200% 0; } }
    
    .fade-in { animation: fadeIn 0.3s ease-out; }
    
    /* Upload Area */
    .upload-area {
      border: 2px dashed var(--hint);
      border-radius: 16px;
      padding: 32px 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      margin-bottom: 16px;
      position: relative;
      overflow: hidden;
    }
    .upload-area:hover, .upload-area:active { 
      border-color: var(--accent);
      transform: scale(0.98);
    }
    .upload-area.has-image { 
      padding: 0; 
      border: none;
      aspect-ratio: 1;
    }
    .upload-area img { 
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 16px;
    }
    .upload-area .change-hint {
      position: absolute;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 12px;
    }
    .upload-area .icon { font-size: 48px; margin-bottom: 8px; }
    .upload-area .hint { color: var(--hint); font-size: 14px; }
    
    input[type="file"] { display: none; }
    
    /* Sample Images */
    .samples {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      overflow-x: auto;
      padding: 4px 0;
      -webkit-overflow-scrolling: touch;
    }
    .samples::-webkit-scrollbar { display: none; }
    .sample-img {
      width: 64px;
      height: 64px;
      border-radius: 12px;
      object-fit: cover;
      cursor: pointer;
      flex-shrink: 0;
      border: 2px solid transparent;
      transition: all 0.2s;
    }
    .sample-img:hover, .sample-img.active {
      border-color: var(--accent);
      transform: scale(1.05);
    }
    .samples-label {
      font-size: 12px;
      color: var(--hint);
      margin-bottom: 8px;
    }
    
    /* Type Toggle */
    .type-toggle {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    .type-btn {
      flex: 1;
      padding: 12px;
      border: 1px solid var(--hint);
      border-radius: 12px;
      background: var(--bg2);
      color: var(--text);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .type-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: var(--accent-text);
    }
    
    /* Presets */
    .presets {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      margin-bottom: 16px;
    }
    .preset-btn {
      padding: 10px 4px;
      border: 1px solid color-mix(in srgb, var(--hint) 50%, transparent);
      border-radius: 10px;
      background: var(--bg2);
      color: var(--text);
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
      position: relative;
      overflow: hidden;
    }
    .preset-btn:hover { transform: scale(0.98); }
    .preset-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: var(--accent-text);
    }
    .preset-btn.loading {
      pointer-events: none;
    }
    .preset-btn .emoji { font-size: 18px; display: block; margin-bottom: 2px; }
    
    /* Progress Bar */
    .progress-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 3px;
      background: var(--accent-text);
      transition: width 0.3s ease-out;
      border-radius: 0 0 12px 12px;
    }
    
    /* Result Area */
    .result-area {
      margin-top: 20px;
    }
    
    /* Job Card */
    .job-card {
      background: var(--bg2);
      border-radius: 16px;
      padding: 16px;
      margin-bottom: 12px;
      animation: fadeIn 0.3s ease-out;
    }
    .job-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .job-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--hint);
    }
    .job-close {
      background: none;
      border: none;
      color: var(--hint);
      font-size: 18px;
      cursor: pointer;
      padding: 4px 8px;
    }
    
    /* Loading State */
    .loading-state {
      padding: 20px;
      text-align: center;
    }
    .progress-container {
      background: color-mix(in srgb, var(--hint) 30%, transparent);
      border-radius: 10px;
      height: 8px;
      overflow: hidden;
      margin-bottom: 12px;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--link));
      border-radius: 10px;
      transition: width 0.5s ease-out;
    }
    .progress-text {
      font-size: 14px;
      color: var(--hint);
    }
    
    /* Result Image */
    .result-media {
      width: 100%;
      border-radius: 12px;
      display: block;
    }
    
    /* Result Actions */
    .result-actions {
      display: flex;
      gap: 12px;
      margin-top: 12px;
    }
    .result-btn {
      flex: 1;
      padding: 12px 16px;
      border: none;
      border-radius: 12px;
      background: var(--accent);
      color: var(--accent-text);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: all 0.2s;
    }
    .result-btn:active { transform: scale(0.95); opacity: 0.9; }
    .result-btn.secondary {
      background: var(--bg);
      color: var(--text);
      border: 1px solid var(--hint);
    }
    
    /* History */
    .history-section {
      margin-top: 24px;
      padding-top: 16px;
      border-top: 1px solid color-mix(in srgb, var(--hint) 30%, transparent);
    }
    .history-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .history-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--hint);
    }
    .history-clear {
      font-size: 12px;
      color: var(--link);
      background: none;
      border: none;
      cursor: pointer;
    }
    .history-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }
    .history-item {
      aspect-ratio: 1;
      border-radius: 12px;
      overflow: hidden;
      cursor: pointer;
      position: relative;
      transition: transform 0.2s;
    }
    .history-item:active { transform: scale(0.95); }
    .history-item img, .history-item video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .history-item .video-badge {
      position: absolute;
      top: 4px;
      right: 4px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
    }
    
    .error { color: #ef4444; text-align: center; padding: 12px; }
    
    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: var(--hint);
    }
    .empty-state .icon { font-size: 48px; margin-bottom: 12px; }
    
    /* User Info Card */
    .user-info {
      margin-bottom: 16px;
    }
    .user-card {
      background: var(--bg2);
      border-radius: 12px;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .user-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: var(--accent);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }
    .user-details {
      flex: 1;
    }
    .user-name {
      font-weight: 600;
      font-size: 16px;
      color: var(--text);
    }
    .user-username {
      font-size: 13px;
      color: var(--link);
    }
    .user-id {
      font-size: 11px;
      color: var(--hint);
      font-family: monospace;
    }
    
    /* Fullscreen Modal */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.95);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }
    .modal.active {
      opacity: 1;
      pointer-events: auto;
    }
    .modal-content {
      max-width: 95vw;
      max-height: 90vh;
      border-radius: 12px;
      transform: scale(0.9);
      transition: transform 0.3s;
    }
    .modal.active .modal-content {
      transform: scale(1);
    }
    .modal-close {
      position: absolute;
      top: 16px;
      right: 16px;
      background: rgba(255,255,255,0.2);
      border: none;
      color: #fff;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
    }
    .modal-actions {
      position: absolute;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
    }
    .modal-btn {
      padding: 12px 24px;
      border: none;
      border-radius: 24px;
      background: rgba(255,255,255,0.2);
      color: #fff;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      backdrop-filter: blur(10px);
    }
    .modal-btn:active { opacity: 0.8; }
  </style>
</head>
<body>
  <div class="container">
    <!-- User Info (Telegram) -->
    <div class="user-info" id="userInfo" style="display: none;">
      <div class="user-card">
        <div class="user-avatar" id="userAvatar">üë§</div>
        <div class="user-details">
          <div class="user-name" id="userName">-</div>
          <div class="user-username" id="userUsername">-</div>
          <div class="user-id" id="userId">ID: -</div>
        </div>
      </div>
    </div>
    
    <!-- Upload Area -->
    <div class="upload-area" id="uploadArea" onclick="document.getElementById('fileInput').click()">
      <div class="icon">üì∑</div>
      <div>Tap to upload image</div>
      <div class="hint">or try a sample below</div>
    </div>
    <input type="file" id="fileInput" accept="image/*">
    
    <!-- Sample Images -->
    <div class="samples-label">‚ú® Try with these</div>
    <div class="samples" id="samples"></div>
    
    <!-- Type Toggle -->
    <div class="type-toggle">
      <button class="type-btn active" data-type="image" onclick="setType('image')">üñºÔ∏è Image</button>
      <button class="type-btn" data-type="video" onclick="setType('video')">üé¨ Video</button>
    </div>
    
    <!-- Presets -->
    <div class="presets" id="presets"></div>
    
    <!-- Results -->
    <div class="result-area" id="resultArea"></div>
    
    <!-- History -->
    <div class="history-section" id="historySection" style="display: none;">
      <div class="history-header">
        <span class="history-title">üìÇ Recent</span>
        <button class="history-clear" onclick="clearHistory()">Clear</button>
      </div>
      <div class="history-grid" id="historyGrid"></div>
    </div>
  </div>
  
  <!-- Fullscreen Modal -->
  <div class="modal" id="modal" onclick="closeModal(event)">
    <button class="modal-close" onclick="closeModal()">‚úï</button>
    <img src="" class="modal-content" id="modalContent">
    <div class="modal-actions">
      <button class="modal-btn" id="modalSave">üíæ Save</button>
      <button class="modal-btn" id="modalShare">üì§ Share</button>
    </div>
  </div>

  <script>
    const API_KEY = 'sa_e5593aa4321e8f12408468cf035ddb7d4bf704a02f16cad0da651bffb341a419';
    const API_URL = 'https://open.eternalai.org';
    
    // Sample images for first-time users
    const SAMPLE_IMAGES = [
      'https://images.unsplash.com/photo-1534528741775-53994a69daeb?w=400',
      'https://images.unsplash.com/photo-1529626455594-4ff0802cfb7e?w=400',
      'https://images.unsplash.com/photo-1524504388940-b1c1722653e1?w=400',
      'https://images.unsplash.com/photo-1517841905240-472988babdf9?w=400',
      'https://images.unsplash.com/photo-1539571696357-5a69c17a67c6?w=400',
    ];
    
    const IMAGE_PRESETS = [
      { emoji: "üî•", label: "Undress", prompt: "Make nude completely. Keep everything else unchanged" },
      { emoji: "üëô", label: "Bikini", prompt: "Change clothes to a bikini. Keep everything else unchanged." },
      { emoji: "ü©±", label: "Lingerie", prompt: "Change clothes to sexy lace lingerie. Keep everything else unchanged." },
      { emoji: "üê∞", label: "Bunny", prompt: "Reimagine as bunny girl cosplay, fitted bodysuit and bunny ears" },
      { emoji: "üõÅ", label: "Towel", prompt: "Replace clothes with small bath towel, wet skin, steamy bathroom" },
      { emoji: "üê±", label: "Catsuit", prompt: "Replace with tight black latex catsuit, shiny material" },
      { emoji: "üëó", label: "Dress", prompt: "Change to elegant tight red dress, low cut, showing curves" },
      { emoji: "üèñÔ∏è", label: "Beach", prompt: "Place on tropical beach, wearing tiny swimsuit, sunny lighting" },
      { emoji: "üé≠", label: "Maid", prompt: "French maid outfit, short skirt, frilly apron and headpiece" },
      { emoji: "‚õìÔ∏è", label: "Leather", prompt: "Black leather harness outfit, edgy and bold style" },
      { emoji: "üßö", label: "Fantasy", prompt: "Mystical elf princess, sheer flowing gown, ethereal lighting" },
      { emoji: "üéÄ", label: "Schoolgirl", prompt: "Japanese schoolgirl uniform, short plaid skirt, white shirt" },
    ];
    
    const VIDEO_PRESETS = [
      { emoji: "üî•", label: "Undress", prompt: "The woman slowly takes off her clothes seductively, revealing her body" },
      { emoji: "üçë", label: "Twerk", prompt: "She turns around and twerks, her body moving rhythmically" },
      { emoji: "üíã", label: "Kiss", prompt: "She blows a kiss to the camera and winks flirtatiously" },
      { emoji: "üôà", label: "Tease", prompt: "She teases by pulling down her top slightly, playful expression" },
      { emoji: "üíÉ", label: "Dance", prompt: "She dances sensually, moving her hips and running hands over body" },
      { emoji: "üòò", label: "Wink", prompt: "She winks and smiles seductively at the camera, bites lip" },
      { emoji: "üîÑ", label: "Turn", prompt: "She slowly turns around showing her body from all angles" },
      { emoji: "üëã", label: "Wave", prompt: "She waves hello cutely then poses with hand on hip" },
      { emoji: "üí®", label: "Hair", prompt: "Wind blows her hair dramatically, she looks stunning" },
      { emoji: "ü§≥", label: "Selfie", prompt: "She takes a selfie pose, duck lips, peace sign, cute angles" },
      { emoji: "üòè", label: "Smirk", prompt: "She gives a knowing smirk and raises one eyebrow seductively" },
      { emoji: "ü´¶", label: "Lips", prompt: "She licks her lips slowly and sensually while looking at camera" },
    ];
    
    let selectedImage = null;
    let originalImage = null;
    let selectedType = 'image';
    let activeJobs = new Map();
    let history = JSON.parse(localStorage.getItem('eai_history') || '[]');
    let sessionResults = []; // Track results to send on close
    
    // Initialize Telegram WebApp
    const tg = window.Telegram?.WebApp;
    if (tg) {
      tg.ready();
      tg.expand();
      tg.enableClosingConfirmation();
      
      // Display user info
      const user = tg.initDataUnsafe?.user;
      if (user) {
        document.getElementById('userInfo').style.display = 'block';
        
        // Name
        const fullName = [user.first_name, user.last_name].filter(Boolean).join(' ');
        document.getElementById('userName').textContent = fullName || 'Unknown';
        
        // Username
        document.getElementById('userUsername').textContent = user.username ? `@${user.username}` : 'No username';
        
        // ID
        document.getElementById('userId').textContent = `ID: ${user.id}`;
        
        // Avatar - first letter of name
        const initial = (user.first_name || 'U').charAt(0).toUpperCase();
        document.getElementById('userAvatar').textContent = initial;
        
        // Log full user data for debugging
        console.log('Telegram User:', user);
        console.log('Full initData:', tg.initData);
        console.log('initDataUnsafe:', tg.initDataUnsafe);
      } else {
        // Not in Telegram or no user data
        document.getElementById('userInfo').style.display = 'block';
        document.getElementById('userName').textContent = 'Not in Telegram';
        document.getElementById('userUsername').textContent = 'Open in Telegram to see user info';
        document.getElementById('userId').textContent = 'ID: N/A';
        console.log('No Telegram user data available');
        console.log('tg object:', tg);
        console.log('initDataUnsafe:', tg?.initDataUnsafe);
      }
    } else {
      // Show debug info when not in Telegram
      document.getElementById('userInfo').style.display = 'block';
      document.getElementById('userName').textContent = 'Telegram WebApp not detected';
      document.getElementById('userUsername').textContent = 'Open via Telegram bot';
      document.getElementById('userId').textContent = 'ID: N/A';
      console.log('Telegram WebApp not available');
    }
    
    // Send results and close
    function sendResultsAndClose() {
      if (!tg) return;
      
      if (sessionResults.length > 0) {
        console.log('Sending results:', sessionResults.length);
        tg.sendData(JSON.stringify({
          action: 'results',
          results: sessionResults,
          count: sessionResults.length
        }));
        // sendData automatically closes the mini-app
      } else {
        tg.close();
      }
    }
    
    // Setup MainButton as "Done" button - only show when results exist
    if (tg) {
      tg.MainButton.setText('Send to Chat');
      tg.MainButton.color = '#7c3aed';
      tg.MainButton.textColor = '#ffffff';
      tg.MainButton.hide(); // Hidden initially
      
      tg.MainButton.onClick(sendResultsAndClose);
      
      // Show button only when results exist
      function updateDoneButton() {
        if (sessionResults.length > 0) {
          tg.MainButton.setText(`Send ${sessionResults.length} to Chat`);
          tg.MainButton.show();
        } else {
          tg.MainButton.hide();
        }
      }
      
      // Watch for new results
      const originalPush = sessionResults.push.bind(sessionResults);
      sessionResults.push = function(...args) {
        const result = originalPush(...args);
        updateDoneButton();
        return result;
      };
    }
    
    // Render samples
    function renderSamples() {
      const container = document.getElementById('samples');
      container.innerHTML = SAMPLE_IMAGES.map((url, i) => `
        <img src="${url}" class="sample-img" onclick="selectSample(${i})" alt="Sample ${i+1}">
      `).join('');
    }
    renderSamples();
    
    // Render presets
    function renderPresets() {
      const presets = selectedType === 'video' ? VIDEO_PRESETS : IMAGE_PRESETS;
      const container = document.getElementById('presets');
      container.innerHTML = presets.map((p, i) => `
        <button class="preset-btn" data-index="${i}" onclick="selectPreset(${i})">
          <span class="emoji">${p.emoji}</span>
          ${p.label}
          <div class="progress-bar" style="width: 0%"></div>
        </button>
      `).join('');
    }
    renderPresets();
    
    // Render history
    function renderHistory() {
      const section = document.getElementById('historySection');
      const grid = document.getElementById('historyGrid');
      
      if (history.length === 0) {
        section.style.display = 'none';
        return;
      }
      
      section.style.display = 'block';
      grid.innerHTML = history.slice(0, 9).map((item, i) => `
        <div class="history-item" onclick="viewHistory(${i})">
          ${item.type === 'video' 
            ? `<video src="${item.url}" muted></video><span class="video-badge">üé¨</span>`
            : `<img src="${item.url}" alt="History">`
          }
        </div>
      `).join('');
    }
    renderHistory();
    
    function selectSample(index) {
      haptic('light');
      const url = SAMPLE_IMAGES[index];
      
      // Mark active
      document.querySelectorAll('.sample-img').forEach((img, i) => {
        img.classList.toggle('active', i === index);
      });
      
      // Load sample
      loadImageFromUrl(url);
    }
    
    async function loadImageFromUrl(url) {
      try {
        const response = await fetch(url);
        const blob = await response.blob();
        const reader = new FileReader();
        reader.onload = async (e) => {
          await setSelectedImage(e.target.result);
        };
        reader.readAsDataURL(blob);
      } catch (err) {
        console.error('Failed to load sample:', err);
        alert('Failed to load sample image');
      }
    }
    
    // Compress image to max dimensions and quality
    async function compressImage(dataUrl, maxSize = 1024, quality = 0.8) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          let { width, height } = img;
          
          // Scale down if needed
          if (width > maxSize || height > maxSize) {
            if (width > height) {
              height = Math.round(height * maxSize / width);
              width = maxSize;
            } else {
              width = Math.round(width * maxSize / height);
              height = maxSize;
            }
          }
          
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, width, height);
          
          resolve(canvas.toDataURL('image/jpeg', quality));
        };
        img.src = dataUrl;
      });
    }
    
    async function setSelectedImage(dataUrl) {
      // Show loading state
      const area = document.getElementById('uploadArea');
      area.innerHTML = `<div style="padding:40px;text-align:center;">Optimizing...</div>`;
      area.classList.add('has-image');
      
      // Compress image
      const compressed = await compressImage(dataUrl, 1024, 0.85);
      selectedImage = compressed;
      originalImage = compressed;
      
      area.innerHTML = `
        <img src="${compressed}" alt="Selected">
        <span class="change-hint">Tap to change</span>
      `;
      
      // Log size for debugging
      const sizeKB = Math.round(compressed.length * 0.75 / 1024);
      console.log(`Image compressed to ~${sizeKB}KB`);
    }
    
    // File upload handler
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      haptic('medium');
      const reader = new FileReader();
      reader.onload = async (e) => {
        await setSelectedImage(e.target.result);
      };
      reader.readAsDataURL(file);
    });
    
    function setType(type) {
      haptic('light');
      selectedType = type;
      document.querySelectorAll('.type-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.type === type);
      });
      renderPresets();
    }
    
    function selectPreset(index) {
      if (!selectedImage) {
        haptic('error');
        alert('Please upload an image first');
        return;
      }
      
      if (activeJobs.has(index)) return;
      
      haptic('medium');
      
      const presets = selectedType === 'video' ? VIDEO_PRESETS : IMAGE_PRESETS;
      const preset = presets[index];
      
      generatePreset(index, preset);
    }
    
    async function generatePreset(index, preset) {
      const resultArea = document.getElementById('resultArea');
      const btn = document.querySelectorAll('.preset-btn')[index];
      const progressBar = btn.querySelector('.progress-bar');
      const jobId = `job-${Date.now()}`;
      
      activeJobs.set(index, jobId);
      btn.classList.add('active', 'loading');
      
      // Create result card
      const jobCard = document.createElement('div');
      jobCard.id = jobId;
      jobCard.className = 'job-card fade-in';
      jobCard.innerHTML = `
        <div class="job-header">
          <span class="job-title">${preset.emoji} ${preset.label}</span>
          <button class="job-close" onclick="removeJob('${jobId}', ${index})">‚úï</button>
        </div>
        <div class="loading-state">
          <div class="progress-container">
            <div class="progress-fill" style="width: 5%"></div>
          </div>
          <div class="progress-text">Starting...</div>
        </div>
      `;
      resultArea.prepend(jobCard);
      
      try {
        const response = await fetch(`${API_URL}/base/generate`, {
          method: 'POST',
          headers: { 'x-api-key': API_KEY, 'Content-Type': 'application/json' },
          body: JSON.stringify({
            images: [selectedImage],
            prompt: preset.prompt,
            type: selectedType
          })
        });
        
        const data = await response.json();
        console.log('API response:', data);
        
        if (!response.ok) {
          throw new Error(data.error || data.message || `API error ${response.status}`);
        }
        if (!data.request_id) {
          throw new Error(data.error || data.message || 'No request ID returned');
        }
        
        const result = await pollResult(data.request_id, jobId, progressBar);
        
        if (result.status === 'success' && result.result_url) {
          haptic('success');
          
          // Save to history
          addToHistory({ url: result.result_url, type: selectedType, preset: preset.label });
          
          // Track for batch send on close
          sessionResults.push({
            url: result.result_url,
            type: selectedType,
            preset: preset.label,
            time: Date.now()
          });
          
          // Show result
          const mediaHtml = selectedType === 'video'
            ? `<video src="${result.result_url}" class="result-media" controls autoplay loop playsinline></video>`
            : `<img src="${result.result_url}" class="result-media" alt="Result" onclick="openModal('${result.result_url}')" style="cursor:pointer;">`;
          
          jobCard.innerHTML = `
            <div class="job-header">
              <span class="job-title">${preset.emoji} ${preset.label}</span>
              <button class="job-close" onclick="removeJob('${jobId}', ${index})">‚úï</button>
            </div>
            ${mediaHtml}
            <div class="result-actions">
              <button class="result-btn secondary" onclick="saveResult('${result.result_url}')">üíæ Save</button>
              <button class="result-btn" onclick="shareResult('${result.result_url}')">üì§ Share</button>
            </div>
          `;
        } else {
          throw new Error('Generation failed');
        }
      } catch (err) {
        haptic('error');
        jobCard.innerHTML = `
          <div class="job-header">
            <span class="job-title">${preset.emoji} ${preset.label}</span>
            <button class="job-close" onclick="removeJob('${jobId}', ${index})">‚úï</button>
          </div>
          <div class="error">‚ùå ${err.message}</div>
        `;
      } finally {
        activeJobs.delete(index);
        btn.classList.remove('active', 'loading');
        progressBar.style.width = '0%';
      }
    }
    
    function removeJob(jobId, index) {
      haptic('light');
      const card = document.getElementById(jobId);
      if (card) {
        card.style.opacity = '0';
        card.style.transform = 'translateX(100%)';
        card.style.transition = 'all 0.3s';
        setTimeout(() => card.remove(), 300);
      }
      activeJobs.delete(index);
      const btn = document.querySelectorAll('.preset-btn')[index];
      if (btn) {
        btn.classList.remove('active', 'loading');
        btn.querySelector('.progress-bar').style.width = '0%';
      }
    }
    
    async function pollResult(requestId, jobId, progressBar, maxAttempts = 90) {
      const card = document.getElementById(jobId);
      const progressFill = card?.querySelector('.progress-fill');
      const progressText = card?.querySelector('.progress-text');
      
      for (let i = 0; i < maxAttempts; i++) {
        await new Promise(r => setTimeout(r, 2000));
        
        const response = await fetch(`${API_URL}/poll-result/${requestId}`);
        const data = await response.json();
        
        if (data.status === 'success') return data;
        if (data.status === 'failed') throw new Error('Generation failed');
        
        // Update progress
        const progress = data.progress || Math.min(5 + i * 2, 95);
        if (progressFill) progressFill.style.width = `${progress}%`;
        if (progressBar) progressBar.style.width = `${progress}%`;
        if (progressText) {
          const msgs = ['Processing...', 'AI is working...', 'Almost there...', 'Finishing up...'];
          progressText.textContent = `${msgs[Math.min(Math.floor(i/5), 3)]} ${progress}%`;
        }
      }
      throw new Error('Timeout');
    }
    
    // History
    function addToHistory(item) {
      history.unshift({ ...item, time: Date.now() });
      history = history.slice(0, 20);
      localStorage.setItem('eai_history', JSON.stringify(history));
      renderHistory();
    }
    
    function viewHistory(index) {
      haptic('light');
      const item = history[index];
      if (!item) return;
      
      // Videos open in new tab, images in modal
      if (item.type === 'video') {
        window.open(item.url, '_blank');
      } else {
        openModal(item.url);
      }
    }
    
    function clearHistory() {
      haptic('medium');
      if (confirm('Clear all history?')) {
        history = [];
        localStorage.removeItem('eai_history');
        renderHistory();
      }
    }
    
    // Actions
    async function saveResult(url) {
      haptic('medium');
      try {
        const response = await fetch(url);
        const blob = await response.blob();
        const blobUrl = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = blobUrl;
        a.download = `eternalai-${Date.now()}.${url.includes('.mp4') ? 'mp4' : 'jpg'}`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(blobUrl);
        haptic('success');
      } catch (err) {
        window.open(url, '_blank');
      }
    }
    
    function shareResult(url) {
      haptic('medium');
      const shareUrl = `https://t.me/share/url?url=${encodeURIComponent(url)}&text=${encodeURIComponent('Made with EternalAI ‚ú®')}`;
      if (tg?.openTelegramLink) {
        tg.openTelegramLink(shareUrl);
      } else {
        window.open(shareUrl, '_blank');
      }
    }
    
    // Haptic feedback helper
    function haptic(type) {
      if (!tg?.HapticFeedback) return;
      switch(type) {
        case 'light': tg.HapticFeedback.impactOccurred('light'); break;
        case 'medium': tg.HapticFeedback.impactOccurred('medium'); break;
        case 'heavy': tg.HapticFeedback.impactOccurred('heavy'); break;
        case 'success': tg.HapticFeedback.notificationOccurred('success'); break;
        case 'error': tg.HapticFeedback.notificationOccurred('error'); break;
      }
    }
    
    // Modal functions
    let currentModalUrl = null;
    
    function openModal(url) {
      haptic('light');
      currentModalUrl = url;
      const modal = document.getElementById('modal');
      const content = document.getElementById('modalContent');
      content.src = url;
      modal.classList.add('active');
      document.body.style.overflow = 'hidden';
      
      // Set up action buttons
      document.getElementById('modalSave').onclick = () => saveResult(url);
      document.getElementById('modalShare').onclick = () => shareResult(url);
    }
    
    function closeModal(event) {
      // Close only if clicking backdrop or close button
      if (event && event.target !== event.currentTarget && !event.target.classList.contains('modal-close')) {
        return;
      }
      haptic('light');
      const modal = document.getElementById('modal');
      modal.classList.remove('active');
      document.body.style.overflow = '';
      currentModalUrl = null;
    }
    
    // Close modal on back button
    window.addEventListener('popstate', () => {
      if (document.getElementById('modal').classList.contains('active')) {
        closeModal();
      }
    });
  </script>
</body>
</html>
